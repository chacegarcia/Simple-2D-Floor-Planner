<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>2D Floor Planner (HTML + JS)</title>
  <link rel="icon" href="favicon.ico" type="image/x-icon"/>
  <style>
    :root{--bg:#0b1220;--panel:#0f172a;--ink:#e7eefb;--muted:#9fb1d1;--accent:#22d3ee;--accent2:#60a5fa;--ring:rgba(34,211,238,.35);--border:#1e293b}
    *{box-sizing:border-box}
    body{margin:0;background:linear-gradient(180deg,#0a0f1e,#0b1220);color:var(--ink);font:14px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;display:grid;grid-template-columns:320px 1fr;min-height:100vh}
    header{grid-column:1/-1;padding:14px 18px;border-bottom:1px solid var(--border);background:#0b1120;position:sticky;top:0;z-index:5}
    header h1{margin:0;font-size:16px;letter-spacing:.3px}
    .sidebar{padding:16px;border-right:1px solid var(--border);background:var(--panel);display:flex;flex-direction:column;gap:14px}
    .card{background:#0b1324;border:1px solid #182235;border-radius:14px;padding:12px}
    .card h2{margin:0 0 8px 0;font-size:13px;color:var(--muted);font-weight:600}
    label{display:block;margin:6px 0 4px 0;color:var(--muted);font-size:12px}
    input,select,button{width:100%;padding:8px 10px;border-radius:10px;background:#0a1222;border:1px solid #1b2740;color:var(--ink);outline:none}
    input:focus,select:focus{border-color:#2c3f63;box-shadow:0 0 0 3px var(--ring)}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    .actions{display:flex;gap:8px;margin-top:8px}
    .actions button{flex:1}
    .muted{color:var(--muted)}
    .pill{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border:1px dashed #2a3b59;border-radius:999px;font-size:12px;color:var(--muted)}
    .canvas-wrap{position:sticky;top:60px;height:calc(100vh - 60px);display:flex;align-items:center;justify-content:center;background:#0a0f1e;overflow:hidden;touch-action:none}
    #stage{background:#060a14;border-left:1px solid var(--border);touch-action:none;-webkit-user-select:none;user-select:none}
    .footerbar{position:fixed;bottom:10px;left:340px;right:14px;background:#0b1324;border:1px solid #182235;border-radius:12px;padding:8px 10px;color:var(--muted);display:flex;gap:16px;align-items:center}
    .swatch{width:14px;height:14px;border-radius:3px;display:inline-block;border:1px solid #0003}

    input[type="checkbox"]{width:auto; accent-color: var(--accent); padding:0;}
    .checkline{display:flex; align-items:center; gap:8px}
  </style>
</head>
<body>
  <header>
    <h1>ðŸ§­ 2D Floor Planner â€” set room size, add rectangles by dimensions, drag & rotate</h1>
  </header>

  <aside class="sidebar">
    <div class="card">
      <h2>Room</h2>
      <input id="ProjectN" type="text" placeholder="Project Name" />
      <div class="row">
        <div>
          <label>Width (units)</label>
          <input id="roomW" type="number" min="1" step="1" value="240" />
        </div>
        <div>
          <label>Height (units)</label>
          <input id="roomH" type="number" min="1" step="1" value="180" />
        </div>
      </div>
      <div class="row">
        <div>
          <label>Scale (px / unit)</label>
          <input id="scale" type="number" min="1" step="1" value="3" />
        </div>
        <div>
          <label>Grid size</label>
          <input id="grid" type="number" min="1" step="1" value="12" />
        </div>
      </div>
      <div class="actions">
        <button id="applyRoom">Apply</button>
        <button id="clearAll" title="Remove all items">Clear</button>
      </div>
      <div class="actions">
        <button id="fitView" title="Fit the whole room on screen">Fit View</button>
        <button id="resetView" title="Reset zoom and pan">Reset View</button>
      </div>
      <div style="margin-top:8px" class="muted">Units are arbitrary (inches, cm, etc.).</div>
    </div>

    <div class="card">
      <h2>Input Mode</h2>
      <label>Controls</label>
      <select id="inputMode">
        <option value="auto">Auto (recommended)</option>
        <option value="desktop">Desktop (mouse / wheel)</option>
        <option value="touch">Touch (iPad / pinch)</option>
      </select>
      <div style="margin-top:8px" class="muted">
        Touch mode enables: 1-finger drag objects, 2-finger pan, pinch zoom.
      </div>
    </div>

    <div class="card">
      <h2>New Rectangle</h2>
      <div class="row">
        <div>
          <label>Width</label>
          <input id="rectW" type="number" min="1" step="1" value="24" />
        </div>
        <div>
          <label>Height</label>
          <input id="rectH" type="number" min="1" step="1" value="18" />
        </div>
      </div>
      <div class="row">
        <div>
          <label>Rotation (Â°)</label>
          <input id="rectRot" type="number" step="1" value="0" />
        </div>
        <div>
          <label>Label</label>
          <input id="rectLabel" type="text" placeholder="Optional" />
        </div>
      </div>
      <div class="row">
        <div>
          <label>Color</label>
          <input id="rectColor" type="color" value="#22d3ee" />
        </div>
        <div>
          <label>Opacity (0.2â€“1)</label>
          <input id="rectAlpha" type="number" min="0.2" max="1" step="0.1" value="0.5" />
        </div>
      </div>
      <button id="addRect">Add Rectangle</button>
      <div style="margin-top:8px" class="muted">Click to select, drag to move. Use the circle handle to rotate.
        Keys:<br>
        <span class="pill">Q/E Â±15Â°</span><span class="pill">G to toggle snap</span>
      </div>
    </div>

    <div class="card" id="selCard" style="display:none">
      <h2>Selected</h2>
      <div class="row">
        <div><label>X</label><input id="selX" type="number" step="1" /></div>
        <div><label>Y</label><input id="selY" type="number" step="1" /></div>
      </div>
      <div class="row">
        <div><label>Width</label><input id="selW" type="number" step="1" /></div>
        <div><label>Height</label><input id="selH" type="number" step="1" /></div>
      </div>
      <div class="row">
        <div><label>Rotation (Â°)</label><input id="selR" type="number" step="1" /></div>
        <div><label>Label</label><input id="selL" type="text" /></div>
      </div>
      <div class="row">
        <div><label>Color</label><input id="selC" type="color" /></div>
        <div><label>Opacity</label><input id="selA" type="number" min="0.2" max="1" step="0.1" /></div>
      </div>
      <div style="margin-top:8px" class="checkline">
        <input id="selLock" type="checkbox" />
        <label for="selLock" style="margin:0;color:var(--muted);font-size:12px">Lock (background)</label>
      </div>
      <div class="actions">
        <button id="deleteSel">Delete</button>
        <button id="dupSel">Duplicate</button>
      </div>
    </div>

    <div class="card">
      <h2>Export / Import</h2>
      <div class="actions">
        <button id="exportPNG">Export PNG</button>
        <button id="exportJSON">Export JSON</button>
      </div>
      <div class="actions">
        <input id="importFile" type="file" accept="application/json" />
        <button id="importJSON">Import</button>
      </div>
    </div>
  </aside>

  <main class="canvas-wrap">
    <canvas id="stage" width="1200" height="800"></canvas>
  </main>

  <div class="footerbar">
    <span id="status">Snap: <strong id="snapState">ON</strong> Â· Cursor: <span id="cursor">0,0</span> Â· Selected: <span id="selInfo">none</span></span>
    <span class="pill">Zoom: <strong id="zoomRead">100%</strong></span>
  </div>

<script>
  // ===== Core State =====
  const canvas = document.getElementById('stage');
  const ctx = canvas.getContext('2d');

  let ROOM_W = 240;
  let ROOM_H = 180;
  let SCALE = 3;
  let GRID = 12;
  let SNAP_TO_GRID = true;
  let THEME = 'screen';

  // ===== View / Camera =====
  let ZOOM = 1;
  const ZOOM_MIN = 0.25;
  const ZOOM_MAX = 6;
  let PAN_X = 0;
  let PAN_Y = 0;
  let SPACE_DOWN = false;

  // ===== Input Mode Toggle =====
  const INPUT_MODE_KEY = 'floorplanner_input_mode';
  let INPUT_MODE = localStorage.getItem(INPUT_MODE_KEY) || 'auto';

  function detectTouchByCapabilities(){
    return window.matchMedia && window.matchMedia('(pointer: coarse)').matches;
  }

  let IS_TOUCH_MODE = false;
  let HANDLE_RADIUS = 8;

  function applyInputMode(mode){
    INPUT_MODE = mode;
    localStorage.setItem(INPUT_MODE_KEY, mode);

    const autoTouch = detectTouchByCapabilities();
    IS_TOUCH_MODE = (mode === 'touch') ? true : (mode === 'desktop') ? false : autoTouch;
    HANDLE_RADIUS = IS_TOUCH_MODE ? 18 : 8;
    SPACE_DOWN = false;

    redraw();
  }

  const rects = []; // {id,x,y,w,h,rot,color,alpha,label,locked}
  let selectedId = null;

  const ui = {
    roomW, roomH, scale, grid, applyRoom, clearAll,
    rectW, rectH, rectRot, rectLabel, rectColor, rectAlpha, addRect,
    selCard, selX, selY, selW, selH, selR, selL, selC, selA, selLock, deleteSel, dupSel,
    exportPNG, exportJSON, importFile, importJSON,
    fitView: document.getElementById('fitView'),
    resetView: document.getElementById('resetView'),
    snapState: document.getElementById('snapState'),
    cursor: document.getElementById('cursor'),
    selInfo: document.getElementById('selInfo'),
    zoomRead: document.getElementById('zoomRead'),
    inputMode: document.getElementById('inputMode')
  };

  function uid(){ return Math.random().toString(36).slice(2,8); }

  function isTextEditing(){
    const el = document.activeElement;
    if(!el) return false;
    const tag = (el.tagName||'').toUpperCase();
    return el.isContentEditable || tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT';
  }

  function snap(v, step){ return Math.round(v / step) * step; }
  function screenToWorld(px, py){ return [px / (SCALE * ZOOM), py / (SCALE * ZOOM)]; }

  function updateZoomReadout(){
    ui.zoomRead.textContent = `${Math.round(ZOOM*100)}%`;
  }

  function clampRectToRoom(r){
    r.w = Math.min(Math.max(1, r.w), ROOM_W);
    r.h = Math.min(Math.max(1, r.h), ROOM_H);
    r.x = Math.max(r.w/2, Math.min(ROOM_W - r.w/2, r.x));
    r.y = Math.max(r.h/2, Math.min(ROOM_H - r.h/2, r.y));
  }

  function getRoomOffset(){
    const wpx = ROOM_W * SCALE * ZOOM;
    const hpx = ROOM_H * SCALE * ZOOM;
    return {ox:(canvas.width - wpx)/2 + PAN_X, oy:(canvas.height - hpx)/2 + PAN_Y};
  }

  function hexToRgba(hex, a){
    const h = hex.replace('#','');
    const bigint = parseInt(h.length===3? h.split('').map(c=>c+c).join(''):h,16);
    const r=(bigint>>16)&255, g=(bigint>>8)&255, b=bigint&255;
    return `rgba(${r},${g},${b},${a})`;
  }

  function drawGrid(){
    const [wpx, hpx] = [ROOM_W * SCALE * ZOOM, ROOM_H * SCALE * ZOOM];
    const palette = THEME === 'exportWhite' ? {
      bg:'#ffffff', room:'#ffffff', roomStroke:'#c7cdd9', grid:'#e6eaf1', origin:'#93a1bb'
    } : {
      bg:'#0a0f1e', room:'#0b1220', roomStroke:'#1f2b45', grid:'#15233d', origin:'#213255'
    };

    ctx.fillStyle = palette.bg;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    const {ox, oy} = getRoomOffset();
    ctx.save();
    ctx.translate(ox, oy);

    ctx.fillStyle = palette.room;
    ctx.strokeStyle = palette.roomStroke;
    ctx.lineWidth = 2;
    ctx.fillRect(0,0,wpx,hpx);
    ctx.strokeRect(0,0,wpx,hpx);

    ctx.strokeStyle = palette.grid;
    ctx.lineWidth = 1;
    const step = GRID * SCALE * ZOOM;

    for(let x=0; x<=wpx; x+=step){
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,hpx); ctx.stroke();
    }
    for(let y=0; y<=hpx; y+=step){
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(wpx,y); ctx.stroke();
    }

    ctx.strokeStyle = palette.origin;
    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(20,0); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(0,20); ctx.stroke();

    ctx.restore();
  }

  function drawRect(r){
    const {ox, oy} = getRoomOffset();
    const cx = ox + r.x * SCALE * ZOOM;
    const cy = oy + r.y * SCALE * ZOOM;
    const w = r.w * SCALE * ZOOM, h = r.h * SCALE * ZOOM;

    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(r.rot * Math.PI/180);

    ctx.fillStyle = hexToRgba(r.color, r.alpha);
    ctx.strokeStyle = selectedId === r.id ? (r.locked ? '#fbbf24' : '#ffffff') : '#2a3b59';
    ctx.lineWidth = selectedId === r.id ? 2.5 : 1.25;
    ctx.beginPath();
    ctx.rect(-w/2, -h/2, w, h);
    ctx.fill(); ctx.stroke();

    if(r.label){
      ctx.fillStyle = (THEME === 'exportWhite' ? '#0b1220' : '#e7eefb');
      ctx.font = '12px system-ui, sans-serif';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(r.label, 0, 0);
    }

    if(selectedId === r.id && !r.locked){
      const handleY = -h/2 - 16;
      ctx.beginPath(); ctx.moveTo(0, -h/2); ctx.lineTo(0, handleY); ctx.strokeStyle = '#6aa3ff'; ctx.stroke();
      ctx.beginPath(); ctx.arc(0, handleY, 6, 0, Math.PI*2); ctx.fillStyle = '#60a5fa'; ctx.fill(); ctx.strokeStyle = '#2a3b59'; ctx.stroke();
    }

    ctx.restore();
  }

  function redraw(){
    drawGrid();
    const {ox, oy} = getRoomOffset();

    ctx.save();
    ctx.beginPath();
    ctx.rect(ox, oy, ROOM_W*SCALE*ZOOM, ROOM_H*SCALE*ZOOM);
    ctx.clip();

    for(const r of rects){ if(r.locked) drawRect(r); }
    for(const r of rects){ if(!r.locked) drawRect(r); }

    ctx.restore();
    updateZoomReadout();
  }

  // ===== Hit Testing =====
  function pointInRect(px, py, r){
    const {ox, oy} = getRoomOffset();
    const cx = ox + r.x * SCALE * ZOOM;
    const cy = oy + r.y * SCALE * ZOOM;

    let x = px - cx, y = py - cy;
    const cos = Math.cos(-r.rot * Math.PI/180), sin = Math.sin(-r.rot * Math.PI/180);
    const lx = x * cos - y * sin;
    const ly = x * sin + y * cos;

    const hw = (r.w * SCALE * ZOOM)/2, hh = (r.h * SCALE * ZOOM)/2;
    return Math.abs(lx) <= hw && Math.abs(ly) <= hh;
  }

  function onHandle(px, py, r){
    if(r.locked) return false;
    const {ox, oy} = getRoomOffset();
    const cx = ox + r.x * SCALE * ZOOM;
    const cy = oy + r.y * SCALE * ZOOM;
    const h = r.h * SCALE * ZOOM;

    const cos = Math.cos(r.rot * Math.PI/180), sin = Math.sin(r.rot * Math.PI/180);
    const localY = (-h/2 - 16);
    const hx = cx + (0 * cos - localY * sin);
    const hy = cy + (0 * sin + localY * cos);

    const d2 = (px - hx)**2 + (py - hy)**2;
    return d2 <= (HANDLE_RADIUS * HANDLE_RADIUS);
  }

  function rectAt(px, py){
    for(let i = rects.length - 1; i >= 0; i--){
      const r = rects[i];
      if(pointInRect(px, py, r)) return r;
    }
    return null;
  }

  // ===== Desktop Interaction =====
  let drag = null; // {type:'move'|'rotate', id, start:{x,y}, orig:{x,y,rot}}
  let panDrag = null;

  canvas.addEventListener('mousemove', (e)=>{
    if(IS_TOUCH_MODE) return;

    const rect = canvas.getBoundingClientRect();
    const px = e.clientX - rect.left, py = e.clientY - rect.top;

    const {ox, oy} = getRoomOffset();
    const [wx, wy] = screenToWorld(px - ox, py - oy);
    ui.cursor.textContent = `${wx.toFixed(1)}, ${wy.toFixed(1)}`;

    if(drag){
      const r = rects.find(rr => rr.id === drag.id);
      if(!r) return;

      if(drag.type === 'move'){
        const dx = (px - drag.start.x) / (SCALE * ZOOM);
        const dy = (py - drag.start.y) / (SCALE * ZOOM);
        let nx = drag.orig.x + dx;
        let ny = drag.orig.y + dy;
        if(SNAP_TO_GRID){ nx = snap(nx, GRID/2); ny = snap(ny, GRID/2); }
        r.x = nx; r.y = ny;
        clampRectToRoom(r);
        syncSelectedPanel();
        redraw();
      } else if(drag.type === 'rotate'){
        const cx = ox + drag.orig.x * SCALE * ZOOM;
        const cy = oy + drag.orig.y * SCALE * ZOOM;
        const ang = Math.atan2(py - cy, px - cx) * 180/Math.PI + 90;
        let rdeg = ang;
        if(SNAP_TO_GRID){ rdeg = snap(rdeg, 5); }
        r.rot = rdeg;
        ui.selR.value = r.rot.toFixed(0);
        redraw();
      }
      return;
    }

    const hit = selectedId ? rects.find(r=>r.id===selectedId) : null;
    if(hit && onHandle(px,py,hit)){
      canvas.style.cursor = 'crosshair';
    } else if(rectAt(px,py)){
      canvas.style.cursor = 'move';
    } else {
      canvas.style.cursor = 'default';
    }
  });

  canvas.addEventListener('mousedown', (e)=>{
    if(IS_TOUCH_MODE) return;

    const rect = canvas.getBoundingClientRect();
    const px = e.clientX - rect.left, py = e.clientY - rect.top;

    if(e.button === 1 || (SPACE_DOWN && e.button === 0)) return;

    if(selectedId){
      const rsel = rects.find(r=>r.id===selectedId);
      if(rsel && !rsel.locked && onHandle(px,py,rsel)){
        drag = {type:'rotate', id:rsel.id, start:{x:px,y:py}, orig:{x:rsel.x,y:rsel.y,rot:rsel.rot}};
        return;
      }
    }

    const r = rectAt(px, py);
    if(r){
      select(r.id);
      if(!r.locked){
        bringToFront(r.id);
        drag = {type:'move', id:r.id, start:{x:px,y:py}, orig:{x:r.x,y:r.y,rot:r.rot}};
      }
    } else {
      select(null);
    }
  });

  canvas.addEventListener('wheel', (e)=>{
    if(IS_TOUCH_MODE) return;
    e.preventDefault();

    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    const {ox, oy} = getRoomOffset();
    const worldX = (mx - ox) / (SCALE * ZOOM);
    const worldY = (my - oy) / (SCALE * ZOOM);

    const factor = (e.deltaY < 0) ? 1.12 : 0.89;
    const newZoom = Math.min(ZOOM_MAX, Math.max(ZOOM_MIN, ZOOM * factor));
    if(newZoom === ZOOM) return;

    ZOOM = newZoom;

    const wpx = ROOM_W * SCALE * ZOOM;
    const hpx = ROOM_H * SCALE * ZOOM;
    const baseOx = (canvas.width - wpx)/2;
    const baseOy = (canvas.height - hpx)/2;

    PAN_X = mx - (baseOx + worldX * SCALE * ZOOM);
    PAN_Y = my - (baseOy + worldY * SCALE * ZOOM);

    redraw();
  }, {passive:false});

  canvas.addEventListener('mousedown', (e)=>{
    if(IS_TOUCH_MODE) return;
    if(e.button === 1 || (SPACE_DOWN && e.button === 0)){
      e.preventDefault();
      panDrag = {startX:e.offsetX, startY:e.offsetY, origPanX:PAN_X, origPanY:PAN_Y};
      canvas.style.cursor = 'grabbing';
    }
  });

  canvas.addEventListener('mousemove', (e)=>{
    if(IS_TOUCH_MODE) return;
    if(panDrag){
      PAN_X = panDrag.origPanX + (e.offsetX - panDrag.startX);
      PAN_Y = panDrag.origPanY + (e.offsetY - panDrag.startY);
      redraw();
    }
  });

  window.addEventListener('mouseup', ()=>{
    drag = null;
    if(panDrag){ panDrag = null; canvas.style.cursor = 'default'; }
  });

  canvas.addEventListener('auxclick', (e)=>{ if(e.button===1) e.preventDefault(); });

  window.addEventListener('keydown',(e)=>{
    if(isTextEditing()) return;

    if(e.code === 'Space' && !IS_TOUCH_MODE){ SPACE_DOWN = true; e.preventDefault(); return; }

    if(e.key.toLowerCase()==='g'){
      SNAP_TO_GRID = !SNAP_TO_GRID;
      ui.snapState.textContent = SNAP_TO_GRID?'ON':'OFF';
    }

    if(!IS_TOUCH_MODE){
      if(e.key === '+' || e.key === '='){ ZOOM = Math.min(ZOOM_MAX, ZOOM * 1.12); redraw(); return; }
      if(e.key === '-'){ ZOOM = Math.max(ZOOM_MIN, ZOOM * 0.89); redraw(); return; }
    }

    if(e.key === 'Delete' || e.key === 'Backspace'){ deleteSelected(); redraw(); return; }

    const r = rects.find(rr=>rr.id===selectedId);
    if(!r || r.locked) return;

    if(e.key.toLowerCase()==='q'){ r.rot -= 15; syncSelectedPanel(); redraw(); }
    if(e.key.toLowerCase()==='e'){ r.rot += 15; syncSelectedPanel(); redraw(); }
    if(e.key==='ArrowLeft'){ r.x -= SNAP_TO_GRID? GRID/2 : 1; clampRectToRoom(r); syncSelectedPanel(); redraw(); }
    if(e.key==='ArrowRight'){ r.x += SNAP_TO_GRID? GRID/2 : 1; clampRectToRoom(r); syncSelectedPanel(); redraw(); }
    if(e.key==='ArrowUp'){ r.y -= SNAP_TO_GRID? GRID/2 : 1; clampRectToRoom(r); syncSelectedPanel(); redraw(); }
    if(e.key==='ArrowDown'){ r.y += SNAP_TO_GRID? GRID/2 : 1; clampRectToRoom(r); syncSelectedPanel(); redraw(); }
  });

  window.addEventListener('keyup',(e)=>{
    if(isTextEditing()) return;
    if(e.code === 'Space' && !IS_TOUCH_MODE){ SPACE_DOWN = false; e.preventDefault(); }
  });

  // ===== Touch Interaction (Pointer Events) =====
  const pointers = new Map();
  let touchPanStart = null;
  let pinchStart = null;

  function getCanvasXY(e){
    const rect = canvas.getBoundingClientRect();
    return {x: e.clientX - rect.left, y: e.clientY - rect.top};
  }
  function pDist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }
  function pMid(a,b){ return {x:(a.x+b.x)/2, y:(a.y+b.y)/2}; }

  canvas.addEventListener('pointerdown', (e)=>{
    if(!IS_TOUCH_MODE) return;
    if(e.pointerType !== 'touch' && e.pointerType !== 'pen') return;

    canvas.setPointerCapture(e.pointerId);
    const p = getCanvasXY(e);
    pointers.set(e.pointerId, p);

    if(pointers.size === 2){
      const pts = [...pointers.values()];
      const m = pMid(pts[0], pts[1]);

      const {ox, oy} = getRoomOffset();
      const worldX = (m.x - ox) / (SCALE * ZOOM);
      const worldY = (m.y - oy) / (SCALE * ZOOM);

      pinchStart = {dist: pDist(pts[0], pts[1]), zoom: ZOOM, worldX, worldY};
      touchPanStart = null;
      drag = null;
      return;
    }

    const r = rectAt(p.x, p.y);
    if(r){
      select(r.id);
      if(!r.locked){
        bringToFront(r.id);
        drag = {type:'move', id:r.id, start:{x:p.x,y:p.y}, orig:{x:r.x,y:r.y,rot:r.rot}};
      } else {
        drag = null;
      }
      touchPanStart = null;
    } else {
      select(null);
      drag = null;
      touchPanStart = {x:p.x, y:p.y, panX:PAN_X, panY:PAN_Y};
    }
  });

  canvas.addEventListener('pointermove', (e)=>{
    if(!IS_TOUCH_MODE) return;
    if(!pointers.has(e.pointerId)) return;

    const p = getCanvasXY(e);
    pointers.set(e.pointerId, p);

    const {ox, oy} = getRoomOffset();
    const [wx, wy] = screenToWorld(p.x - ox, p.y - oy);
    ui.cursor.textContent = `${wx.toFixed(1)}, ${wy.toFixed(1)}`;

    if(pointers.size === 2 && pinchStart){
      const pts = [...pointers.values()];
      const m = pMid(pts[0], pts[1]);
      const d = pDist(pts[0], pts[1]);

      let newZoom = pinchStart.zoom * (d / pinchStart.dist);
      newZoom = Math.min(ZOOM_MAX, Math.max(ZOOM_MIN, newZoom));
      ZOOM = newZoom;

      const wpx = ROOM_W * SCALE * ZOOM;
      const hpx = ROOM_H * SCALE * ZOOM;
      const baseOx = (canvas.width - wpx)/2;
      const baseOy = (canvas.height - hpx)/2;

      PAN_X = m.x - (baseOx + pinchStart.worldX * SCALE * ZOOM);
      PAN_Y = m.y - (baseOy + pinchStart.worldY * SCALE * ZOOM);

      redraw();
      return;
    }

    if(touchPanStart && !drag){
      PAN_X = touchPanStart.panX + (p.x - touchPanStart.x);
      PAN_Y = touchPanStart.panY + (p.y - touchPanStart.y);
      redraw();
      return;
    }

    if(drag && drag.type === 'move'){
      const r = rects.find(rr=>rr.id === drag.id);
      if(!r || r.locked) return;

      const dx = (p.x - drag.start.x) / (SCALE * ZOOM);
      const dy = (p.y - drag.start.y) / (SCALE * ZOOM);
      let nx = drag.orig.x + dx;
      let ny = drag.orig.y + dy;

      if(SNAP_TO_GRID){ nx = snap(nx, GRID/2); ny = snap(ny, GRID/2); }

      r.x = nx; r.y = ny;
      clampRectToRoom(r);
      syncSelectedPanel();
      redraw();
    }
  });

  function endTouchPointer(e){
    if(!IS_TOUCH_MODE) return;
    pointers.delete(e.pointerId);
    if(pointers.size < 2) pinchStart = null;
    if(pointers.size === 0){
      drag = null;
      touchPanStart = null;
    }
  }
  canvas.addEventListener('pointerup', endTouchPointer);
  canvas.addEventListener('pointercancel', endTouchPointer);

  // ===== Selection + UI sync =====
  function bringToFront(id){
    const idx = rects.findIndex(r=>r.id===id);
    if(idx>=0){ const [r]=rects.splice(idx,1); rects.push(r); redraw(); }
  }
  function sendToBack(id){
    const idx = rects.findIndex(r=>r.id===id);
    if(idx>=0){ const [r]=rects.splice(idx,1); rects.unshift(r); redraw(); }
  }
  function select(id){ selectedId = id; syncSelectedPanel(); redraw(); }

  function getSel(){ return rects.find(rr=>rr.id===selectedId) || null; }

  function syncSelectedPanel(){
    const r = getSel();
    if(!r){
      ui.selCard.style.display='none';
      ui.selInfo.textContent='none';
      return;
    }
    ui.selCard.style.display='block';
    ui.selX.value = r.x.toFixed(1);
    ui.selY.value = r.y.toFixed(1);
    ui.selW.value = r.w.toFixed(1);
    ui.selH.value = r.h.toFixed(1);
    ui.selR.value = r.rot.toFixed(0);
    ui.selL.value = r.label || '';
    ui.selC.value = r.color;
    ui.selA.value = r.alpha.toFixed(1);
    ui.selLock.checked = !!r.locked;
    ui.selInfo.textContent = `${r.label||'rect'} (${r.w}Ã—${r.h} @ ${r.rot}Â°)`;
  }

  ui.selX.addEventListener('input', ()=>{ const r=getSel(); if(!r) return; r.x = +ui.selX.value; clampRectToRoom(r); redraw(); });
  ui.selY.addEventListener('input', ()=>{ const r=getSel(); if(!r) return; r.y = +ui.selY.value; clampRectToRoom(r); redraw(); });
  ui.selW.addEventListener('input', ()=>{ const r=getSel(); if(!r) return; r.w = Math.max(1,+ui.selW.value); clampRectToRoom(r); syncSelectedPanel(); redraw(); });
  ui.selH.addEventListener('input', ()=>{ const r=getSel(); if(!r) return; r.h = Math.max(1,+ui.selH.value); clampRectToRoom(r); syncSelectedPanel(); redraw(); });
  ui.selR.addEventListener('input', ()=>{ const r=getSel(); if(!r) return; r.rot = +ui.selR.value; redraw(); });
  ui.selL.addEventListener('input', ()=>{ const r=getSel(); if(!r) return; r.label = ui.selL.value; redraw(); });
  ui.selC.addEventListener('input', ()=>{ const r=getSel(); if(!r) return; r.color = ui.selC.value; redraw(); });
  ui.selA.addEventListener('input', ()=>{ const r=getSel(); if(!r) return; r.alpha = Math.min(1, Math.max(0.2, +ui.selA.value)); redraw(); });

  ui.selLock.addEventListener('change', ()=>{
    const r=getSel(); if(!r) return;
    r.locked = ui.selLock.checked;
    if(r.locked) sendToBack(r.id);
    syncSelectedPanel();
    redraw();
  });

  function deleteSelected(){
    const idx = rects.findIndex(r=>r.id===selectedId);
    if(idx>=0){ rects.splice(idx,1); select(null); }
  }
  ui.deleteSel.addEventListener('click', deleteSelected);

  ui.dupSel.addEventListener('click', ()=>{
    const r=getSel(); if(!r) return;
    const copy = {...r, id:uid(), x:r.x + r.w/4, y:r.y + r.h/4};
    rects.push(copy);
    select(copy.id);
  });

  // ===== View helpers =====
  function resetView(){ ZOOM=1; PAN_X=0; PAN_Y=0; redraw(); }
  function fitToScreen(){
    const pad = 40;
    const roomPxW = ROOM_W * SCALE;
    const roomPxH = ROOM_H * SCALE;
    const zx = (canvas.width  - pad*2) / roomPxW;
    const zy = (canvas.height - pad*2) / roomPxH;
    ZOOM = Math.min(ZOOM_MAX, Math.max(ZOOM_MIN, Math.min(zx, zy)));
    PAN_X = 0; PAN_Y = 0;
    redraw();
  }
  ui.fitView.addEventListener('click', fitToScreen);
  ui.resetView.addEventListener('click', resetView);

  // ===== Buttons =====
  ui.applyRoom.addEventListener('click',()=>{
    ROOM_W = Math.max(1, +ui.roomW.value);
    ROOM_H = Math.max(1, +ui.roomH.value);
    SCALE  = Math.max(1, +ui.scale.value);
    GRID   = Math.max(1, +ui.grid.value);

    for(const r of rects) clampRectToRoom(r);

    const maxW = window.innerWidth - 360, maxH = window.innerHeight - 120;
    const wpx = Math.min(ROOM_W*SCALE, Math.max(800, maxW));
    const hpx = Math.min(ROOM_H*SCALE, Math.max(600, maxH));
    canvas.width = Math.round(Math.max(600, wpx));
    canvas.height= Math.round(Math.max(400, hpx));
    redraw();
  });

  ui.clearAll.addEventListener('click', ()=>{ rects.length=0; select(null); redraw(); });

  ui.addRect.addEventListener('click', ()=>{
    const w = Math.max(1, +ui.rectW.value);
    const h = Math.max(1, +ui.rectH.value);
    const rot = +ui.rectRot.value || 0;
    const color = ui.rectColor.value;
    const alpha = Math.min(1, Math.max(0.2, +ui.rectAlpha.value));
    const label = ui.rectLabel.value.trim();
    const r = {id:uid(), x:w/2+1, y:h/2+1, w, h, rot, color, alpha, label, locked:false};
    if(SNAP_TO_GRID){ r.x = snap(r.x, GRID/2); r.y = snap(r.y, GRID/2); }
    clampRectToRoom(r);
    rects.push(r);
    select(r.id);
  });

  ui.exportPNG.addEventListener('click', ()=>{
    const Proj_Name = document.getElementById('ProjectN').value || 'floorplan';

    const off = document.createElement('canvas');
    off.width = Math.round(ROOM_W * SCALE);
    off.height = Math.round(ROOM_H * SCALE);
    const octx = off.getContext('2d');

    octx.fillStyle = '#ffffff';
    octx.fillRect(0,0,off.width,off.height);

    octx.strokeStyle = '#c7cdd9';
    octx.lineWidth = 2;
    octx.strokeRect(0,0,off.width,off.height);

    const step = GRID * SCALE;
    octx.strokeStyle = '#e6eaf1';
    octx.lineWidth = 1;
    for(let x=0; x<=off.width; x+=step){ octx.beginPath(); octx.moveTo(x,0); octx.lineTo(x,off.height); octx.stroke(); }
    for(let y=0; y<=off.height; y+=step){ octx.beginPath(); octx.moveTo(0,y); octx.lineTo(off.width,y); octx.stroke(); }

    for(const r of rects){
      const cx = r.x * SCALE, cy = r.y * SCALE;
      const ww = r.w * SCALE, hh = r.h * SCALE;
      octx.save();
      octx.translate(cx, cy);
      octx.rotate(r.rot * Math.PI/180);
      octx.fillStyle = hexToRgba(r.color, r.alpha);
      octx.strokeStyle = '#2a3b59';
      octx.lineWidth = 1.25;
      octx.beginPath();
      octx.rect(-ww/2, -hh/2, ww, hh);
      octx.fill(); octx.stroke();
      if(r.label){
        octx.fillStyle = '#0b1220';
        octx.font = '12px system-ui, sans-serif';
        octx.textAlign='center'; octx.textBaseline='middle';
        octx.fillText(r.label, 0, 0);
      }
      octx.restore();
    }

    const url = off.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = url;
    a.download = Proj_Name + '.png';
    a.click();
  });

  ui.exportJSON.addEventListener('click', ()=>{
    const Proj_Name = document.getElementById('ProjectN').value || 'floorplan';
    const data = { room:{w:ROOM_W,h:ROOM_H,scale:SCALE,grid:GRID}, snap:SNAP_TO_GRID, rects };
    const blob = new Blob([JSON.stringify(data,null,2)], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href=url; a.download=Proj_Name + '.json';
    a.click();
    setTimeout(()=>URL.revokeObjectURL(url), 1000);
  });

  ui.importJSON.addEventListener('click', ()=>{
    const f = ui.importFile.files?.[0];
    if(!f) return alert('Choose a JSON file first');
    const fr = new FileReader();
    fr.onload = ()=>{
      try{
        const d = JSON.parse(fr.result);
        ROOM_W = d.room.w; ROOM_H = d.room.h; SCALE = d.room.scale; GRID = d.room.grid; SNAP_TO_GRID = !!d.snap;
        rects.length = 0;
        for(const r of d.rects){ rects.push({locked:false, ...r}); }
        ui.roomW.value=ROOM_W; ui.roomH.value=ROOM_H; ui.scale.value=SCALE; ui.grid.value=GRID;
        ui.snapState.textContent = SNAP_TO_GRID?'ON':'OFF';
        select(null);
        ui.applyRoom.click();
      }catch(err){
        alert('Invalid JSON');
      }
    };
    fr.readAsText(f);
  });

  // ===== Init =====
  if(ui.inputMode){
    ui.inputMode.value = INPUT_MODE;
    ui.inputMode.addEventListener('change', () => applyInputMode(ui.inputMode.value));
  }
  applyInputMode(INPUT_MODE);

  const mq = window.matchMedia && window.matchMedia('(pointer: coarse)');
  if(mq && mq.addEventListener){
    mq.addEventListener('change', ()=>{ if(INPUT_MODE === 'auto') applyInputMode('auto'); });
  }

  ui.applyRoom.click();
  redraw();
</script>
</body>
</html>
